üß± Phase 1 : Fondations Data & Backend (Le Socle)

L'objectif est d'avoir une base de donn√©es solide avant de toucher au moindre pixel.
√âtape 1.1 : Migration SQL et Sch√©ma

Prompt Cline :
code Text

    
Agis en tant qu'Architecte Base de Donn√©es.
Je dois impl√©menter un syst√®me de "Dynamic Tables" (type Grist/Airtable) dans Supabase pour mon application Next.js.

T√¢che :
1. Cr√©e un fichier de migration SQL dans `supabase/migrations` (utilise le timestamp actuel).
2. D√©finis les 3 tables suivantes :
   - `entity_tables` : id, workspace_id, name, description, created_at.
   - `entity_fields` : id, table_id, name, type (text, number, select, date, etc.), options (jsonb pour les choix du select), order_index, created_at.
   - `entity_records` : id, table_id, data (JSONB pour stocker les valeurs dynamiques), created_at, updated_at.
3. Ajoute les contraintes Foreign Keys (workspace_id, table_id) avec `ON DELETE CASCADE`.
4. Active RLS (Row Level Security) sur les 3 tables.
5. √âcris des policies RLS g√©n√©riques : seul un membre authentifi√© du workspace concern√© peut lire/√©crire.

Ne lance pas la migration, √©cris juste le fichier SQL proprement.

  

√âtape 1.2 : Mise √† jour des Types TypeScript

Une fois la migration appliqu√©e (via supabase db push ou manuellement).

Prompt Cline :
code Text

    
Mets √† jour les d√©finitions de types TypeScript.
1. Regarde le fichier SQL cr√©√© pr√©c√©demment ou introspecte la DB si possible.
2. Mets √† jour (ou cr√©e) le fichier `types/database.ts` ou `types/tables.ts` pour inclure les interfaces TypeScript pr√©cises pour `EntityTable`, `EntityField` et `EntityRecord`.
3. Pour `EntityRecord`, le champ `data` doit √™tre typ√© comme `Record<string, any>` pour l'instant pour permettre la flexibilit√© JSON.

  

√âtape 1.3 : Server Actions (CRUD Structure)

Prompt Cline :
code Text

    
Cr√©e les Server Actions pour g√©rer la structure des tables.
Fichier : `app/actions/tables-structure.ts`

Impl√©mente les fonctions suivantes (s√©curis√©es et valid√©es avec Zod) :
1. `createTable(workspaceId, name)`
2. `createField(tableId, fieldData)` : fieldData doit contenir name, type, et options.
3. `updateField(fieldId, updates)` : pour renommer ou changer les options.
4. `deleteField(fieldId)`
5. `getTables(workspaceId)` : pour lister les tables d'un workspace.

Utilise `createClient` de `@supabase/ssr` ou ta config existante. G√®re les erreurs try/catch.

  

√âtape 1.4 : Server Actions (CRUD Donn√©es)

Prompt Cline :
code Text

    
Cr√©e les Server Actions pour manipuler les donn√©es (les lignes du tableau).
Fichier : `app/actions/tables-data.ts`

Impl√©mente :
1. `getRecords(tableId)` : R√©cup√®re toutes les lignes d'une table.
2. `upsertRecord(tableId, recordData)` : `recordData` est l'objet JSON complet de la ligne.
   - Si l'ID existe, update le JSONB.
   - Sinon, insert une nouvelle ligne.
3. `deleteRecord(recordId)`

Note : Assure-toi que la validation v√©rifie que l'utilisateur a bien acc√®s √† la table via son workspace.

  

üé® Phase 2 : Frontend - Le Moteur (TanStack Table)

Ici, on installe le moteur sans l'interface "Drag & Drop" complexe pour commencer.
√âtape 2.1 : Setup et Affichage Lecture Seule

Prompt Cline :
code Text

    
T√¢che Frontend - Initialisation du tableau.
1. Installe `@tanstack/react-table` si ce n'est pas fait.
2. Cr√©e un composant `components/datatable/DataTable.tsx`.
3. Ce composant doit recevoir en props :
   - `fields` (Array of EntityField)
   - `records` (Array of EntityRecord)
4. Initialise `useReactTable` en mode basique :
   - Transforme les `fields` en `columns` TanStack.
   - Mappe les `records` (champ .data) en `data` TanStack.
5. Affiche une simple table HTML stylis√©e avec Tailwind/Shadcn pour v√©rifier que les donn√©es s'affichent correctement. Pas d'√©dition pour l'instant.

  

√âtape 2.2 : Cellules Editables (Le c≈ìur du sujet)

Prompt Cline :
code Text

    
Rends le tableau interactif (√âdition des cellules).
1. Cr√©e un composant g√©n√©rique `components/datatable/EditableCell.tsx`.
2. Ce composant doit :
   - Afficher la valeur en mode texte par d√©faut.
   - Devenir un Input (ou Select selon le type de champ) au clic.
   - Avoir un `onBlur` qui d√©clenche une prop `onUpdate`.
3. Int√®gre ce composant dans `DataTable.tsx` via le `cell` renderer des colonnes TanStack.
4. Connecte le tout √† la Server Action `upsertRecord` via un appel optimiste (mise √† jour UI imm√©diate).

  

üõ†Ô∏è Phase 3 : Gestion des Colonnes (Le Builder)

L'utilisateur doit pouvoir construire sa table.
√âtape 3.1 : Header Interactif

Prompt Cline :
code Text

    
Am√©liore les en-t√™tes de colonnes.
1. Cr√©e un composant `components/datatable/ColumnHeader.tsx`.
2. Utilise un `DropdownMenu` (Shadcn) dans le header qui propose :
   - "Renommer" (ouvre un petit dialog ou input popover).
   - "Supprimer la colonne".
   - "Changer le type" (ex: Text vers Number).
3. Connecte ces actions aux Server Actions de `tables-structure.ts`.
4. Remplace le header par d√©faut de TanStack par ce composant.

  

√âtape 3.2 : Ajout de colonne

Prompt Cline :
code Text

    
Ajoute la fonctionnalit√© "Nouvelle Colonne".
1. Dans `DataTable.tsx`, ajoute une "fausse" colonne √† la fin (ou un bouton "+" √† droite des headers).
2. Au clic, ouvre un Dialog (Shadcn) ou un Popover demandant :
   - Le nom de la colonne.
   - Le type (Text, Number, Select...).
3. √Ä la validation, appelle la Server Action `createField` et rafra√Æchis la vue.

  

üöÄ Phase 4 : UX Avanc√©e (Drag & Drop)

La touche finale pour faire "Pro".
√âtape 4.1 : Installation et Setup DnD

Prompt Cline :
code Text

    
Int√®gre le Drag and Drop pour les colonnes.
1. Installe `@dnd-kit/core`, `@dnd-kit/sortable`, `@dnd-kit/modifiers`.
2. Modifie `DataTable.tsx` pour envelopper le header (`<thead>` ou √©quivalent) avec `DndContext` et `SortableContext`.
3. Rends les `ColumnHeader` "draggables".
4. G√®re l'√©v√©nement `onDragEnd` pour mettre √† jour l'ordre visuel localement.

  

√âtape 4.2 : Persistance de l'ordre

Prompt Cline :
code Text

    
Persistance de l'ordre des colonnes.
1. Ajoute une Server Action `reorderFields(tableId, orderedFieldIds)` dans `tables-structure.ts`.
2. Dans le `onDragEnd` du frontend, appelle cette action pour sauvegarder le nouvel index (`order_index`) en base de donn√©es.
3. Assure-toi que lors du chargement initial des donn√©es, les champs sont tri√©s par `order_index`.

  

Conseils pour toi (le chef d'orchestre)

    V√©rifie entre chaque √©tape : Lance npm run dev apr√®s chaque √©tape Frontend. V√©rifie que √ßa compile et que √ßa ressemble √† quelque chose. Si Cline casse le design, dis-lui "Stop, le style a saut√©, corrige le CSS Tailwind".

    Fichiers s√©par√©s : Si tu vois que Cline commence √† √©crire EditableCell √† l'int√©rieur du fichier DataTable.tsx, arr√™te-le et dis : "Extrais ce composant dans son propre fichier dans /components/datatable/". C'est vital pour la maintenabilit√©.

    Les Types : C'est l√† que √ßa va coincer le plus souvent (JSONB vs Typescript). Si tu as des erreurs de type "any", demande √† Cline de cr√©er un Type Guard ou une interface sp√©cifique, mais ne le laisse pas mettre des // @ts-ignore partout.