üìã CODEBASE ARCHITECTURE - COMPLET
üìä supabase/migrations/20251224_add_invitations_system.sql

-- Phase 2: User Invitations System
-- This migration adds the ability to invite users to organizations

-- 1. Create workspace_invitations table
CREATE TABLE IF NOT EXISTS workspace_invitations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  token TEXT UNIQUE NOT NULL,
  role TEXT DEFAULT 'member',
  created_by_user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMP DEFAULT now(),
  expires_at TIMESTAMP DEFAULT (now() + INTERVAL '7 days'),
  accepted_at TIMESTAMP,
  accepted_by_user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Partial unique index: only one pending invitation per email per organization
CREATE UNIQUE INDEX IF NOT EXISTS idx_unique_pending_invite_per_email 
ON workspace_invitations(organization_id, email) 
WHERE accepted_by_user_id IS NULL;

-- 3. Create indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_workspace_invitations_token ON workspace_invitations(token);
CREATE INDEX IF NOT EXISTS idx_workspace_invitations_org ON workspace_invitations(organization_id);
CREATE INDEX IF NOT EXISTS idx_workspace_invitations_email ON workspace_invitations(email);
CREATE INDEX IF NOT EXISTS idx_workspace_invitations_accepted_user ON workspace_invitations(accepted_by_user_id);

-- 4. Enable RLS on workspace_invitations
ALTER TABLE workspace_invitations ENABLE ROW LEVEL SECURITY;

-- 5. RLS Policy: Anyone can view pending invitations sent to their email
CREATE POLICY "Users can view invitations sent to their email" ON workspace_invitations
  FOR SELECT USING (
    auth.jwt() ->> 'email' = email OR
    auth.uid() = created_by_user_id
  );

-- 6. RLS Policy: Organization admins can create invitations
CREATE POLICY "Organization admins can create invitations" ON workspace_invitations
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM organization_members
      WHERE organization_id = workspace_invitations.organization_id
      AND user_id = auth.uid()
      AND role IN ('owner', 'admin')
    )
  );

-- 7. RLS Policy: Users can accept their own invitations
CREATE POLICY "Users can accept their own invitations" ON workspace_invitations
  FOR UPDATE USING (
    auth.jwt() ->> 'email' = email AND accepted_at IS NULL
  )
  WITH CHECK (
    auth.jwt() ->> 'email' = email AND
    accepted_by_user_id = auth.uid()
  );

-- 8. RLS Policy: Organization admins can delete invitations
CREATE POLICY "Organization admins can delete invitations" ON workspace_invitations
  FOR DELETE USING (
    EXISTS (
      SELECT 1 FROM organization_members
      WHERE organization_id = workspace_invitations.organization_id
      AND user_id = auth.uid()
      AND role IN ('owner', 'admin')
    )
  );

-- Add comment for clarity
COMMENT ON TABLE workspace_invitations IS 
'User invitations to organizations. Users are invited via email with a unique token. They accept the invitation by clicking the token link.';

COMMENT ON COLUMN workspace_invitations.token IS
'Unique token used in invitation link: /invitations/{token}';

COMMENT ON COLUMN workspace_invitations.role IS
'Role the invited user will have: owner, admin, or member';

COMMENT ON COLUMN workspace_invitations.expires_at IS
'Invitation expires after 7 days by default. Null means never expires.';
üîµ types/entities.ts

export type FieldType = 'text' | 'number' | 'select' | 'date' | 'boolean' | 'email' | 'url' | 'richtext' | 'json' | 'relation';

// Phase 3: Project (Table Space) - intermediate level between workspace and tables
export interface Project {
  id: string;
  workspace_id: string;
  name: string;
  description: string | null;
  color: string | null;
  created_at: string;
  updated_at: string;
}

export interface EntityTable {
  id: string;
  workspace_id: string;
  project_id: string | null; // Reference to project (Phase 3)
  name: string;
  description: string | null;
  created_at: string;
  updated_at: string;
}

export interface EntityField {
  id: string;
  table_id: string;
  name: string;
  type: FieldType;
  order_index: number;
  // Options pour les selects ou la config des relations
  options: {
    choices?: { label: string; color?: string; id: string }[];
    target_table_id?: string; // Pour les relations
    [key: string]: any;
  } | null;
}

export interface EntityRecord {
  id: string;
  table_id: string;
  // Record<string, any> permet de stocker { "field_id_123": "Valeur" }
  data: Record<string, any>;
  created_at: string;
  updated_at: string;
}

// Type compos√© utile pour le frontend (Table + ses champs)
export interface EntityTableWithFields extends EntityTable {
  fields: EntityField[];
}

// Phase 3: Workspace hierarchy - projects with their tables
export interface ProjectWithTables extends Project {
  tables: EntityTable[];
}

export interface WorkspaceHierarchy {
  projects: ProjectWithTables[];
  tablesWithoutProject: EntityTable[]; // For backwards compatibility
}
üîê lib/types/action-result.ts

/**
 * Error codes for categorizing server action failures
 */
export enum ErrorCode {
  AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR',
  AUTHORIZATION_ERROR = 'AUTHORIZATION_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  NOT_FOUND = 'NOT_FOUND',
  DATABASE_ERROR = 'DATABASE_ERROR',
  UNKNOWN_ERROR = 'UNKNOWN_ERROR',
}

/**
 * Structured error object for server actions
 */
export interface ActionError {
  code: ErrorCode
  message: string
  details?: unknown
}

/**
 * Type-safe result wrapper using discriminated union
 *
 * @example
 * // Success case
 * const result = await createProjectAction(input)
 * if (result.success) {
 *   console.log(result.data) // TypeScript knows this is Project
 * } else {
 *   console.log(result.error.message)
 * }
 *
 * // Using helpers
 * const { data, error } = result
 * if (error) {
 *   console.log(error.code) // Can handle specific error codes
 * }
 */
export type ActionResult<T> =
  | { success: true; data: T }
  | { success: false; error: ActionError }

/**
 * Convert any error to structured ActionError
 *
 * Maps custom error classes:
 * - AuthenticationError ‚Üí AUTHENTICATION_ERROR
 * - WorkspaceAccessError ‚Üí AUTHORIZATION_ERROR
 * - NotFoundError ‚Üí NOT_FOUND
 * - ZodError ‚Üí VALIDATION_ERROR (with generic message)
 * - Supabase database errors (code 23*) ‚Üí DATABASE_ERROR
 * - Other Error objects ‚Üí UNKNOWN_ERROR
 *
 * @param error - Any error object
 * @returns Structured ActionError
 */
export function toActionError(error: unknown): ActionError {
  // Handle custom error classes by name
  if (error && typeof error === 'object' && 'name' in error) {
    const errorName = (error as any).name
    const message = (error as Error).message

    if (errorName === 'AuthenticationError') {
      return {
        code: ErrorCode.AUTHENTICATION_ERROR,
        message,
      }
    }

    if (errorName === 'WorkspaceAccessError') {
      return {
        code: ErrorCode.AUTHORIZATION_ERROR,
        message,
      }
    }

    if (errorName === 'NotFoundError') {
      return {
        code: ErrorCode.NOT_FOUND,
        message,
      }
    }

    if (errorName === 'ZodError') {
      return {
        code: ErrorCode.VALIDATION_ERROR,
        message: 'Validation failed. Please check your input.',
        details: error,
      }
    }
  }

  // Handle Supabase/database errors with code
  if (error && typeof error === 'object' && 'code' in error && 'message' in error) {
    const dbError = error as { code?: string; message?: string }
    if (dbError.code && dbError.code.match(/^23/)) {
      return {
        code: ErrorCode.DATABASE_ERROR,
        message: 'Database operation failed. Please try again.',
        details: dbError,
      }
    }
  }

  // Handle generic Error objects
  if (error instanceof Error) {
    return {
      code: ErrorCode.UNKNOWN_ERROR,
      message: error.message,
    }
  }

  // Fallback for unknown error types
  return {
    code: ErrorCode.UNKNOWN_ERROR,
    message: 'An unknown error occurred.',
    details: error,
  }
}

/**
 * Create a success result
 *
 * @example
 * return success(project)
 */
export function success<T>(data: T): ActionResult<T> {
  return { success: true, data }
}

/**
 * Create an error result
 *
 * @example
 * catch (error) {
 *   return failure(error)
 * }
 */
export function failure<T = never>(error: unknown): ActionResult<T> {
  return { success: false, error: toActionError(error) }
}

/**
 * Extract error message from ActionResult
 *
 * @example
 * const message = getErrorMessage(result) // string | null
 */
export function getErrorMessage<T>(result: ActionResult<T>): string | null {
  return result.success ? null : result.error.message
}

/**
 * Extract error code from ActionResult
 *
 * @example
 * const code = getErrorCode(result) // ErrorCode | null
 * if (code === ErrorCode.AUTHENTICATION_ERROR) {
 *   // redirect to login
 * }
 */
export function getErrorCode<T>(result: ActionResult<T>): ErrorCode | null {
  return result.success ? null : result.error.code
}
üîë lib/auth/workspace.ts

import type { SupabaseClient } from '@supabase/ssr'
import type { User } from '@supabase/supabase-js'

/**
 * Custom error for authorization failures
 */
export class WorkspaceAccessError extends Error {
  constructor(message: string = 'You do not have access to this workspace.') {
    super(message)
    this.name = 'WorkspaceAccessError'
  }
}

/**
 * Custom error for authentication failures
 */
export class AuthenticationError extends Error {
  constructor(message: string = 'You must be logged in.') {
    super(message)
    this.name = 'AuthenticationError'
  }
}

/**
 * Custom error for resource not found
 */
export class NotFoundError extends Error {
  constructor(resource: string = 'Resource') {
    super(`${resource} not found.`)
    this.name = 'NotFoundError'
  }
}

/**
 * Authenticate user and return User object
 * Throws AuthenticationError if not authenticated
 *
 * @param supabase - Supabase client instance
 * @returns Authenticated User object
 *
 * @example
 * const user = await requireAuth(supabase)
 * // Now you have the user and can use user.id
 */
export async function requireAuth(supabase: SupabaseClient): Promise<User> {
  const { data: authData, error: authError } = await supabase.auth.getUser()

  if (authError || !authData.user) {
    throw new AuthenticationError()
  }

  return authData.user
}

/**
 * Verify user has access to a specific workspace (organization)
 * Throws WorkspaceAccessError if no access
 *
 * @param supabase - Supabase client instance
 * @param userId - User ID to check
 * @param workspaceId - Workspace (organization) ID
 * @returns Membership object if access granted
 *
 * @example
 * await requireWorkspaceAccess(supabase, user.id, workspaceId)
 * // If this doesn't throw, user has access
 */
export async function requireWorkspaceAccess(
  supabase: SupabaseClient,
  userId: string,
  workspaceId: string
): Promise<{ organization_id: string }> {
  const { data: membership, error: membershipError } = await supabase
    .from('organization_members')
    .select('organization_id')
    .eq('organization_id', workspaceId)
    .eq('user_id', userId)
    .maybeSingle()

  if (membershipError || !membership) {
    throw new WorkspaceAccessError()
  }

  return membership
}

/**
 * Verify a project belongs to the specified workspace
 * Throws NotFoundError if project doesn't exist or doesn't belong to workspace
 *
 * @param supabase - Supabase client instance
 * @param projectId - Project ID to verify
 * @param workspaceId - Expected workspace ID
 * @returns Project workspace_id if valid
 *
 * @example
 * await requireProjectInWorkspace(supabase, projectId, workspaceId)
 * // If this doesn't throw, project belongs to workspace
 */
export async function requireProjectInWorkspace(
  supabase: SupabaseClient,
  projectId: string,
  workspaceId: string
): Promise<{ workspace_id: string }> {
  const { data: project, error: projectError } = await supabase
    .from('projects')
    .select('workspace_id')
    .eq('id', projectId)
    .eq('workspace_id', workspaceId)
    .maybeSingle()

  if (projectError || !project) {
    throw new NotFoundError('Project')
  }

  return project
}

/**
 * Verify a table belongs to the specified workspace
 * Throws NotFoundError if table doesn't exist or doesn't belong to workspace
 *
 * @param supabase - Supabase client instance
 * @param tableId - Table ID to verify
 * @param workspaceId - Expected workspace ID
 * @returns Table workspace_id if valid
 *
 * @example
 * await requireTableInWorkspace(supabase, tableId, workspaceId)
 * // If this doesn't throw, table belongs to workspace
 */
export async function requireTableInWorkspace(
  supabase: SupabaseClient,
  tableId: string,
  workspaceId: string
): Promise<{ workspace_id: string }> {
  const { data: table, error: tableError } = await supabase
    .from('entity_tables')
    .select('workspace_id')
    .eq('id', tableId)
    .eq('workspace_id', workspaceId)
    .maybeSingle()

  if (tableError || !table) {
    throw new NotFoundError('Table')
  }

  return table
}

/**
 * Verify a record belongs to the specified workspace (via its table)
 * Throws NotFoundError if record doesn't exist or doesn't belong to workspace
 *
 * @param supabase - Supabase client instance
 * @param recordId - Record ID to verify
 * @param workspaceId - Expected workspace ID
 * @returns Record table_id if valid
 *
 * @example
 * await requireRecordInWorkspace(supabase, recordId, workspaceId)
 * // If this doesn't throw, record belongs to workspace
 */
export async function requireRecordInWorkspace(
  supabase: SupabaseClient,
  recordId: string,
  workspaceId: string
): Promise<{ table_id: string }> {
  const { data: record, error: recordError } = await supabase
    .from('entity_records')
    .select('table:entity_tables(workspace_id), id, table_id')
    .eq('id', recordId)
    .maybeSingle()

  if (recordError || !record) {
    throw new NotFoundError('Record')
  }

  // Check workspace access via nested table
  if ((record as any).table?.workspace_id !== workspaceId) {
    throw new NotFoundError('Record')
  }

  return { table_id: (record as any).table_id }
}

/**
 * Verify a field belongs to the specified workspace (via its table)
 * Throws NotFoundError if field doesn't exist or doesn't belong to workspace
 *
 * @param supabase - Supabase client instance
 * @param fieldId - Field ID to verify
 * @param workspaceId - Expected workspace ID
 * @returns Field table_id if valid
 *
 * @example
 * await requireFieldInWorkspace(supabase, fieldId, workspaceId)
 * // If this doesn't throw, field belongs to workspace
 */
export async function requireFieldInWorkspace(
  supabase: SupabaseClient,
  fieldId: string,
  workspaceId: string
): Promise<{ table_id: string }> {
  const { data: field, error: fieldError } = await supabase
    .from('entity_fields')
    .select('table:entity_tables(workspace_id), id, table_id')
    .eq('id', fieldId)
    .maybeSingle()

  if (fieldError || !field) {
    throw new NotFoundError('Field')
  }

  // Check workspace access via nested table
  if ((field as any).table?.workspace_id !== workspaceId) {
    throw new NotFoundError('Field')
  }

  return { table_id: (field as any).table_id }
}

/**
 * All-in-one helper: authenticate user AND verify workspace access
 * Returns both user and supabase client for convenience
 * Throws on any failure
 *
 * @param workspaceId - Workspace to verify access to
 * @returns Object with user and supabase client
 *
 * @example
 * const { user, supabase } = await requireAuthAndWorkspace(workspaceId)
 * // Now you have both and know user has workspace access
 */
export async function requireAuthAndWorkspace(workspaceId: string): Promise<{
  user: User
  supabase: SupabaseClient
}> {
  const supabase = await createClient()
  const user = await requireAuth(supabase)
  await requireWorkspaceAccess(supabase, user.id, workspaceId)

  return { user, supabase }
}

/**
 * Wrapper for server actions: automatically handles auth, workspace access, and error handling
 *
 * @param workspaceId - Required workspace ID for authorization
 * @param handler - Function that receives (user, supabase, input) and returns result
 * @returns Server action function that takes input and returns { success, data, error }
 *
 * @example
 * export const createProjectAction = protectedAction(
 *   async ({ user, supabase }, input: CreateProjectInput) => {
 *     const result = await supabase
 *       .from('projects')
 *       .insert({ workspace_id: input.workspace_id, ... })
 *       .single()
 *     return result
 *   },
 *   {
 *     getWorkspaceId: (input) => input.workspace_id
 *   }
 * )
 *
 * // Or without workspace requirement (for things like creating workspace):
 * export const createWorkspaceAction = protectedAction(
 *   async ({ user, supabase }, input) => {
 *     // ...
 *   }
 * )
 */
export function protectedAction<TInput, TOutput>(
  handler: (
    context: { user: User; supabase: SupabaseClient },
    input: TInput
  ) => Promise<TOutput>,
  options?: {
    /** Function to extract workspaceId from input (optional) */
    getWorkspaceId?: (input: TInput) => string
  }
) {
  return async (input: TInput): Promise<{ success: boolean; data?: TOutput; error?: string }> => {
    try {
      const supabase = await createClient()
      const user = await requireAuth(supabase)

      // Verify workspace access if required
      if (options?.getWorkspaceId) {
        const workspaceId = options.getWorkspaceId(input)
        await requireWorkspaceAccess(supabase, user.id, workspaceId)
      }

      const result = await handler({ user, supabase }, input)
      return { success: true, data: result }
    } catch (error) {
      // Return error with proper context
      const errorMessage =
        error instanceof Error ? error.message : 'An unknown error occurred.'
      return { success: false, error: errorMessage }
    }
  }
}
‚úÖ lib/validations/auth.ts

import { z } from 'zod'

export const signUpSchema = z
  .object({
    full_name: z.string().min(2, {
      message: 'Le nom doit contenir au moins 2 caract√®res.',
    }),
    email: z.string().email({
      message: 'Veuillez entrer une adresse email valide.',
    }),
    password: z.string().min(8, {
      message: 'Le mot de passe doit contenir au moins 8 caract√®res.',
    }),
    confirm_password: z.string(),
  })
  .refine((data) => data.password === data.confirm_password, {
    message: 'Les mots de passe ne correspondent pas.',
    path: ['confirm_password'],
  })

export const signInSchema = z.object({
  email: z.string().email({
    message: 'Veuillez entrer une adresse email valide.',
  }),
  password: z.string().min(1, {
    message: 'Le mot de passe est requis.',
  }),
})

export type SignUpInput = z.infer<typeof signUpSchema>
export type SignInInput = z.infer<typeof signInSchema>
‚úÖ lib/validations/entities.ts

import { z } from 'zod'

/**
 * Field type enum - Matches database CHECK constraint
 * Supports text, number, select, date, boolean, email, url, richtext, json, relation
 */
export const fieldTypeSchema = z.enum([
  'text',
  'number',
  'select',
  'date',
  'boolean',
  'email',
  'url',
  'richtext',
  'json',
  'relation',
] as const)

export type FieldType = z.infer<typeof fieldTypeSchema>

/**
 * Create a new entity table
 * Requires: workspace_id, name
 * Optional: description, project_id (Phase 3)
 */
export const createTableSchema = z.object({
  workspace_id: z.string().uuid({
    message: 'workspace_id doit √™tre un UUID valide.',
  }),
  project_id: z.string().uuid({
    message: 'project_id doit √™tre un UUID valide.',
  }).nullable().optional(),
  name: z.string().min(1, {
    message: 'Le nom de la table est requis.',
  }).max(255, {
    message: 'Le nom de la table ne peut pas d√©passer 255 caract√®res.',
  }),
  description: z.string().max(1000).optional().default(''),
})

export type CreateTableInput = z.infer<typeof createTableSchema>

/**
 * Create a new field in an entity table
 * Requires: table_id, name, type
 * Optional: options (JSONB configuration), order_index
 */
export const createFieldSchema = z.object({
  table_id: z.string().uuid({
    message: 'table_id doit √™tre un UUID valide.',
  }),
  name: z.string().min(1, {
    message: 'Le nom du champ est requis.',
  }).max(255, {
    message: 'Le nom du champ ne peut pas d√©passer 255 caract√®res.',
  }),
  type: fieldTypeSchema,
  options: z.record(z.string(), z.any()).optional().default({}),
  order_index: z.number().int().min(0).optional().default(0),
})

export type CreateFieldInput = z.infer<typeof createFieldSchema>

/**
 * Update an existing field
 * Requires: field_id
 * Optional: name, type, options (partial update)
 */
export const updateFieldSchema = z.object({
  field_id: z.string().uuid({
    message: 'field_id doit √™tre un UUID valide.',
  }),
  name: z.string().min(1).max(255).optional(),
  type: fieldTypeSchema.optional(),
  options: z.record(z.string(), z.any()).optional(),
  order_index: z.number().int().min(0).optional(),
}).refine(
  // At least one field should be updated
  (data) => Object.keys(data).length > 1,
  {
    message: 'Au moins un champ doit √™tre modifi√©.',
  }
)

export type UpdateFieldInput = z.infer<typeof updateFieldSchema>

/**
 * Create or update a record in an entity table
 * Requires: table_id, data (JSONB object)
 * data keys should match field IDs, values match field types
 */
export const upsertRecordSchema = z.object({
  table_id: z.string().uuid({
    message: 'table_id doit √™tre un UUID valide.',
  }),
  data: z.record(z.string(), z.any()).optional().default({}),
})

export type UpsertRecordInput = z.infer<typeof upsertRecordSchema>
üîê app/actions/auth.ts

'use server'

import { createClient } from '@/lib/supabase/server'
import { getCurrentUser } from '@/lib/supabase/auth'
import { redirect } from 'next/navigation'
import { revalidatePath } from 'next/cache'

/**
 * Poll until a condition is met or timeout is reached
 * @param condition - Function that returns true when condition is met
 * @param maxAttempts - Maximum number of attempts (default: 10)
 * @param delayMs - Delay between attempts in milliseconds (default: 500)
 */
async function pollUntil(
  condition: () => Promise<boolean>,
  maxAttempts: number = 10,
  delayMs: number = 500
): Promise<boolean> {
  for (let i = 0; i < maxAttempts; i++) {
    if (await condition()) {
      return true
    }
    if (i < maxAttempts - 1) {
      await new Promise(resolve => setTimeout(resolve, delayMs))
    }
  }
  return false
}

export async function signUpAction(formData: {
  email: string
  password: string
  fullName: string
  invitationToken?: string
}) {
  const supabase = await createClient()

  // Signup simple sans redirections complexes
  const { data: signUpData, error: signUpError } = await supabase.auth.signUp({
    email: formData.email,
    password: formData.password,
    options: {
      data: {
        full_name: formData.fullName,
      },
    },
  })

  if (signUpError) {
    // Check if user already exists
    if (signUpError.message.includes('already registered') || 
        signUpError.message.includes('User already exists')) {
      return { 
        error: 'Cet email est d√©j√† utilis√©. Veuillez vous connecter √† votre compte ou utiliser un autre email.', 
        success: false 
      }
    }
    return { error: signUpError.message, success: false }
  }

  if (!signUpData.user) {
    return { error: 'Erreur lors de la cr√©ation du compte', success: false }
  }

  // Poll until profile is created by Supabase auth trigger
  const userId = signUpData.user.id
  const profileCreated = await pollUntil(
    async () => {
      const { data } = await supabase
        .from('profiles')
        .select('id')
        .eq('id', userId)
        .maybeSingle()
      return !!data
    },
    15,
    300
  )

  if (!profileCreated) {
    console.warn('Profile not created after polling, continuing anyway')
  }

  // Connexion automatique avec les m√™mes credentials
  const { error: signInError } = await supabase.auth.signInWithPassword({
    email: formData.email,
    password: formData.password,
  })

  if (signInError) {
    console.error('Auto-login error:', signInError)
    return { 
      error: 'Compte cr√©√© ! Connectez-vous maintenant avec vos identifiants.', 
      success: true 
    }
  }

  // If invitation token provided, accept the invitation automatically
  if (formData.invitationToken) {
    try {
      const { error: inviteError } = await supabase
        .from('workspace_invitations')
        .update({
          accepted_at: new Date().toISOString(),
          accepted_by_user_id: userId,
        })
        .eq('token', formData.invitationToken)
        .eq('email', formData.email.toLowerCase())

      if (inviteError) {
        console.warn('Could not accept invitation:', inviteError)
      } else {
        console.log('[signUpAction] Invitation accepted for token:', formData.invitationToken)
      }
    } catch (err) {
      console.warn('[signUpAction] Error accepting invitation:', err)
    }
  }

  revalidatePath('/', 'layout')
  redirect('/after-signup')
}

export async function signInAction(formData: {
  email: string
  password: string
}) {
  const supabase = await createClient()

  const { error } = await supabase.auth.signInWithPassword({
    email: formData.email,
    password: formData.password,
  })

  if (error) {
    return { error: error.message }
  }

  revalidatePath('/', 'layout')
  redirect('/dashboard')
}

export async function signOutAction() {
  const supabase = await createClient()
  await supabase.auth.signOut()
  revalidatePath('/', 'layout')
  redirect('/')
}


export async function createOrganizationAction(formData: {
  name: string
  slug: string
  description?: string
}) {
  const supabase = await createClient()

  // Get current user
  const { data: { user }, error: userError } = await supabase.auth.getUser()

  console.log('[createOrganizationAction] User:', user?.id, 'Error:', userError)

  if (userError || !user) {
    return { error: 'Non authentifi√©' }
  }

  // Create organization
  const { data: organization, error: orgError } = await supabase
    .from('organizations')
    .insert({
      name: formData.name,
      slug: formData.slug,
      description: formData.description || null,
      created_by: user.id,
    })
    .select()
    .single()

  console.log('[createOrganizationAction] Organization created:', organization?.id, 'Error:', orgError)

  if (orgError) {
    return { error: orgError.message }
  }

  if (!organization) {
    return { error: 'Erreur lors de la cr√©ation de l\'organisation' }
  }

  // Create organization member (owner)
  const { error: memberError } = await supabase
    .from('organization_members')
    .insert({
      organization_id: organization.id,
      user_id: user.id,
      role: 'owner',
    })

  console.log('[createOrganizationAction] Member created for org:', organization.id, 'user:', user.id, 'Error:', memberError)

  if (memberError) {
    // Rollback: delete the organization if member creation fails
    await supabase.from('organizations').delete().eq('id', organization.id)
    console.log('[createOrganizationAction] Rolled back organization due to member error')
    return { error: 'Erreur lors de l\'ajout comme membre: ' + memberError.message }
  }

  console.log('[createOrganizationAction] Success, revalidating and redirecting to /dashboard')
  revalidatePath('/', 'layout')
  redirect('/dashboard')
}
üéØ app/actions/entities/workspace.ts

'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'
import type { EntityTable } from '@/types/entities'

/**
 * Poll until a condition is met or timeout is reached
 * Used to wait for Supabase RLS to sync new memberships
 */
async function pollUntil(
  condition: () => Promise<boolean>,
  maxAttempts: number = 20,
  delayMs: number = 200
): Promise<boolean> {
  for (let i = 0; i < maxAttempts; i++) {
    if (await condition()) {
      return true
    }
    if (i < maxAttempts - 1) {
      await new Promise(resolve => setTimeout(resolve, delayMs))
    }
  }
  return false
}

/**
 * Create a new workspace (Organization) for the authenticated user
 * 
 * @param formData - { name, slug, description? }
 * @returns { success: true, data: { id } } or { success: false, error: message }
 */
export async function createWorkspaceAction(formData: {
  name: string
  slug: string
  description?: string
}) {
  const supabase = await createClient()

  // Get current user
  const { data: { user }, error: userError } = await supabase.auth.getUser()

  if (userError || !user) {
    return {
      success: false,
      error: 'Non authentifi√©',
    }
  }

  // Validate input
  if (!formData.name || !formData.slug) {
    return {
      success: false,
      error: 'Le nom et le slug sont requis',
    }
  }

  // Check if slug already exists for this user
  const { data: existingWorkspace } = await supabase
    .from('organizations')
    .select('id')
    .eq('slug', formData.slug)
    .eq('created_by', user.id)
    .maybeSingle()

  if (existingWorkspace) {
    return {
      success: false,
      error: 'Ce slug est d√©j√† utilis√©',
    }
  }

  // Create organization
  const { data: organization, error: orgError } = await supabase
    .from('organizations')
    .insert({
      name: formData.name,
      slug: formData.slug,
      description: formData.description || null,
      created_by: user.id,
    })
    .select()
    .single()

  if (orgError) {
    console.error('Error creating organization:', orgError)
    return {
      success: false,
      error: orgError.message,
    }
  }

  if (!organization) {
    return {
      success: false,
      error: 'Erreur lors de la cr√©ation du workspace',
    }
  }

  // Create organization member (owner)
  const { error: memberError } = await supabase
    .from('organization_members')
    .insert({
      organization_id: organization.id,
      user_id: user.id,
      role: 'owner',
    })

  if (memberError) {
    // Rollback: delete the organization if member creation fails
    await supabase.from('organizations').delete().eq('id', organization.id)
    console.error('Error creating member:', memberError)
    return {
      success: false,
      error: 'Erreur lors de l\'ajout comme membre: ' + memberError.message,
    }
  }

  // Success - wait for RLS to recognize the new membership
  // Poll until the membership is visible through RLS policy
  const membershipVisible = await pollUntil(
    async () => {
      const { data } = await supabase
        .from('organization_members')
        .select('id')
        .eq('organization_id', organization.id)
        .eq('user_id', user.id)
        .maybeSingle()
      return !!data
    },
    20,
    200
  )

  if (!membershipVisible) {
    console.warn('Membership not visible via RLS after polling, continuing anyway')
  }

  // Revalidate and redirect
  revalidatePath('/dashboard', 'layout')
  revalidatePath('/', 'layout')
  
  // Use server-side redirect to ensure data is ready
  redirect('/dashboard')
}

/**
 * Get all entity tables for a workspace
 *
 * @param workspaceId - UUID of the workspace (organization)
 * @returns { success: true, data: EntityTable[] } or { success: false, error: message }
 */
export async function getWorkspaceTablesAction(workspaceId: string) {
  try {
    // ===== 1. AUTHENTICATE USER
    const supabase = await createClient()
    const { data: authData, error: authError } = await supabase.auth.getUser()

    if (authError || !authData.user) {
      return {
        success: false,
        error: 'Vous devez √™tre connect√© pour acc√©der aux tables.',
      }
    }

    // ===== 2. VERIFY USER HAS ACCESS TO WORKSPACE
    const { data: membership, error: membershipError } = await supabase
      .from('organization_members')
      .select('organization_id')
      .eq('organization_id', workspaceId)
      .eq('user_id', authData.user.id)
      .maybeSingle()

    if (membershipError || !membership) {
      return {
        success: false,
        error: 'Vous n\'avez pas acc√®s √† ce workspace.',
      }
    }

    // ===== 3. FETCH ALL TABLES FOR THIS WORKSPACE
    const { data: tables, error: tablesError } = await supabase
      .from('entity_tables')
      .select('*')
      .eq('workspace_id', workspaceId)
      .order('created_at', { ascending: false })

    if (tablesError) {
      console.error('Error fetching tables:', tablesError)
      return {
        success: false,
        error: 'Impossible de r√©cup√©rer les tables.',
      }
    }

    // ===== 4. RETURN SUCCESS
    return {
      success: true,
      data: (tables || []) as EntityTable[],
    }
  } catch (error) {
    console.error('Error in getWorkspaceTablesAction:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Une erreur inconnue est survenue.',
    }
  }
}
üìã app/actions/entities/tables.ts

'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import {
  createTableSchema,
  type CreateTableInput,
} from '@/lib/validations/entities'
import {
  requireAuth,
  requireWorkspaceAccess,
  requireProjectInWorkspace,
} from '@/lib/auth/workspace'
import { success, failure, type ActionResult } from '@/lib/types/action-result'
import type {
  EntityTable,
  EntityField,
  EntityTableWithFields,
} from '@/types/entities'

/**
 * Create a new entity table in a workspace or project
 *
 * @param input - CreateTableInput with workspace_id, name, description, and optional project_id
 * @returns ActionResult<EntityTable>
 */
export async function createEntityTableAction(
  input: CreateTableInput
): Promise<ActionResult<EntityTable>> {
  try {
    const supabase = await createClient()
    const user = await requireAuth(supabase)

    // Validate input
    const validatedInput = createTableSchema.parse(input)

    // Verify workspace access
    await requireWorkspaceAccess(supabase, user.id, validatedInput.workspace_id)

    // If project_id provided, verify it belongs to workspace
    if (validatedInput.project_id) {
      await requireProjectInWorkspace(
        supabase,
        validatedInput.project_id,
        validatedInput.workspace_id
      )
    }

    // Create table
    const { data: newTable, error: insertError } = await supabase
      .from('entity_tables')
      .insert({
        workspace_id: validatedInput.workspace_id,
        project_id: validatedInput.project_id || null,
        name: validatedInput.name,
        description: validatedInput.description,
      })
      .select('*')
      .single()

    if (insertError || !newTable) {
      throw new Error('Impossible de cr√©er la table. Veuillez r√©essayer.')
    }

    // Revalidate cache
    revalidatePath('/dashboard')
    revalidatePath(`/workspace/${validatedInput.workspace_id}`)
    if (validatedInput.project_id) {
      revalidatePath(`/workspace/${validatedInput.workspace_id}/project/${validatedInput.project_id}`)
    }

    return success(newTable as EntityTable)
  } catch (error) {
    return failure(error)
  }
}

/**
 * Get entity table details with all its fields
 *
 * @param tableId - UUID of the entity_table
 * @returns ActionResult<EntityTableWithFields>
 */
export async function getEntityTableDetailsAction(
  tableId: string
): Promise<ActionResult<EntityTableWithFields>> {
  try {
    const supabase = await createClient()
    const user = await requireAuth(supabase)

    // Fetch table with fields
    const { data: table, error: tableError } = await supabase
      .from('entity_tables')
      .select('*, fields:entity_fields(*)')
      .eq('id', tableId)
      .maybeSingle()

    if (tableError) {
      throw new Error('Impossible de r√©cup√©rer la table.')
    }

    if (!table) {
      throw new Error('Table non trouv√©e.')
    }

    // Verify workspace access
    await requireWorkspaceAccess(supabase, user.id, table.workspace_id)

    // Sort fields by order_index
    const sortedFields = (table.fields as EntityField[]).sort(
      (a, b) => a.order_index - b.order_index
    )

    // Build response
    const result: EntityTableWithFields = {
      id: table.id,
      workspace_id: table.workspace_id,
      project_id: table.project_id,
      name: table.name,
      description: table.description,
      created_at: table.created_at,
      updated_at: table.updated_at,
      fields: sortedFields,
    }

    return success(result)
  } catch (error) {
    return failure(error)
  }
}
üîß app/actions/entities/fields.ts

'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import {
  createFieldSchema,
  updateFieldSchema,
  type CreateFieldInput,
  type UpdateFieldInput,
} from '@/lib/validations/entities'
import {
  requireAuth,
  requireWorkspaceAccess,
  NotFoundError,
} from '@/lib/auth/workspace'
import { success, failure, type ActionResult } from '@/lib/types/action-result'
import type {
  EntityField,
} from '@/types/entities'

/**
 * Create a new field in an entity table
 *
 * @param input - CreateFieldInput with table_id, name, type, options
 * @returns ActionResult<EntityField>
 */
export async function createEntityFieldAction(
  input: CreateFieldInput
): Promise<ActionResult<EntityField>> {
  try {
    const supabase = await createClient()
    const user = await requireAuth(supabase)

    // Validate input
    const validatedInput = createFieldSchema.parse(input)

    // Verify user has access to workspace (via parent table)
    const { data: parentTable, error: tableError } = await supabase
      .from('entity_tables')
      .select('workspace_id')
      .eq('id', validatedInput.table_id)
      .maybeSingle()

    if (tableError || !parentTable) {
      throw new NotFoundError('Table parente non trouv√©e.')
    }

    // Verify workspace access
    await requireWorkspaceAccess(supabase, user.id, parentTable.workspace_id)

    // Calculate order_index
    const { data: maxOrderField } = await supabase
      .from('entity_fields')
      .select('order_index')
      .eq('table_id', validatedInput.table_id)
      .order('order_index', { ascending: false })
      .limit(1)
      .maybeSingle()

    const newOrderIndex = maxOrderField ? (maxOrderField as any).order_index + 1 : 0

    // Insert field
    const { data: newField, error: insertError } = await supabase
      .from('entity_fields')
      .insert({
        table_id: validatedInput.table_id,
        name: validatedInput.name,
        type: validatedInput.type,
        options: validatedInput.options || {},
        order_index: newOrderIndex,
      })
      .select('*')
      .single()

    if (insertError || !newField) {
      throw new Error('Impossible de cr√©er le champ. Veuillez r√©essayer.')
    }

    // Revalidate cache
    revalidatePath('/dashboard')
    revalidatePath(`/table/${validatedInput.table_id}`)

    return success(newField as EntityField)
  } catch (error) {
    return failure(error)
  }
}

/**
 * Update an existing field
 *
 * @param input - UpdateFieldInput with field_id and optional fields to update
 * @returns ActionResult<EntityField>
 */
export async function updateEntityFieldAction(
  input: UpdateFieldInput
): Promise<ActionResult<EntityField>> {
  try {
    const supabase = await createClient()
    const user = await requireAuth(supabase)

    // Validate input
    const validatedInput = updateFieldSchema.parse(input)

    // Get field and verify workspace access
    const { data: field, error: fieldError } = await supabase
      .from('entity_fields')
      .select('table_id, table:entity_tables(workspace_id)')
      .eq('id', validatedInput.field_id)
      .maybeSingle()

    if (fieldError || !field) {
      throw new NotFoundError('Champ')
    }

    // Verify workspace access via table
    const workspaceId = (field as any).table?.workspace_id
    if (!workspaceId) {
      throw new NotFoundError('Table parente non trouv√©e.')
    }
    await requireWorkspaceAccess(supabase, user.id, workspaceId)

    // Build update object
    const updateData: Record<string, any> = {}
    if (validatedInput.name !== undefined) updateData.name = validatedInput.name
    if (validatedInput.type !== undefined) updateData.type = validatedInput.type
    if (validatedInput.options !== undefined) updateData.options = validatedInput.options
    if (validatedInput.order_index !== undefined) updateData.order_index = validatedInput.order_index

    // Update field
    const { data: updatedField, error: updateError } = await supabase
      .from('entity_fields')
      .update(updateData)
      .eq('id', validatedInput.field_id)
      .select('*')
      .single()

    if (updateError || !updatedField) {
      throw new Error('Impossible de modifier le champ. Veuillez r√©essayer.')
    }

    // Revalidate cache
    revalidatePath('/dashboard')
    revalidatePath(`/table/${(field as any).table_id}`)

    return success(updatedField as EntityField)
  } catch (error) {
    return failure(error)
  }
}

/**
 * Delete an entity field
 *
 * @param fieldId - UUID of the field to delete
 * @returns ActionResult<void>
 */
export async function deleteEntityFieldAction(fieldId: string): Promise<ActionResult<void>> {
  try {
    const supabase = await createClient()
    const user = await requireAuth(supabase)

    // Get field and verify workspace access
    const { data: field, error: fieldError } = await supabase
      .from('entity_fields')
      .select('table_id, table:entity_tables(workspace_id)')
      .eq('id', fieldId)
      .maybeSingle()

    if (fieldError || !field) {
      throw new NotFoundError('Champ')
    }

    // Verify workspace access via table
    const workspaceId = (field as any).table?.workspace_id
    if (!workspaceId) {
      throw new NotFoundError('Table parente non trouv√©e.')
    }
    await requireWorkspaceAccess(supabase, user.id, workspaceId)

    // Delete field
    const { error: deleteError } = await supabase
      .from('entity_fields')
      .delete()
      .eq('id', fieldId)

    if (deleteError) {
      throw new Error('Impossible de supprimer le champ. Veuillez r√©essayer.')
    }

    // Revalidate cache
    revalidatePath('/dashboard')
    revalidatePath(`/table/${(field as any).table_id}`)

    return success(undefined)
  } catch (error) {
    return failure(error)
  }
}
üíæ app/actions/entities/records.ts

'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import {
  upsertRecordSchema,
  type UpsertRecordInput,
} from '@/lib/validations/entities'
import {
  requireAuth,
  requireTableInWorkspace,
  NotFoundError,
} from '@/lib/auth/workspace'
import { success, failure, type ActionResult } from '@/lib/types/action-result'
import type { EntityRecord } from '@/types/entities'

/**
 * Phase 4 - Entity Records Server Actions
 *
 * Manages records (data) within entity tables.
 * All actions use centralized auth helpers and pagination support.
 */

// ===== PAGINATION TYPES
export interface PaginatedRecords {
  records: EntityRecord[]
  total: number
  page: number
  pageSize: number
  hasNextPage: boolean
  hasPreviousPage: boolean
  totalPages: number
}

// ===== GET RECORDS WITH PAGINATION
/**
 * Fetch records from a table with pagination support
 *
 * @param tableId - UUID of the entity_table
 * @param page - Page number (1-indexed), default: 1
 * @param pageSize - Records per page, default: 50
 * @returns ActionResult<PaginatedRecords>
 *
 * @example
 * const result = await getEntityRecordsAction(tableId, 1, 50)
 * // Returns: { success: true, data: { total: 1000, hasNextPage: true, records: [...50 items] } }
 */
export async function getEntityRecordsAction(
  tableId: string,
  page: number = 1,
  pageSize: number = 50
): Promise<ActionResult<PaginatedRecords>> {
  try {
    const supabase = await createClient()
    await requireAuth(supabase)

    // Validate pagination params
    if (page < 1) page = 1
    if (pageSize < 1 || pageSize > 500) pageSize = 50 // Max 500 per page

    // ===== VERIFY TABLE EXISTS AND USER HAS ACCESS
    const { data: table } = await supabase
      .from('entity_tables')
      .select('workspace_id')
      .eq('id', tableId)
      .maybeSingle()

    if (!table) {
      throw new NotFoundError('Table')
    }

    // Verify workspace access (uses helper)
    await requireTableInWorkspace(supabase, tableId, table.workspace_id)

    // ===== FETCH TOTAL COUNT (for pagination metadata)
    const { count: total, error: countError } = await supabase
      .from('entity_records')
      .select('*', { count: 'exact', head: true })
      .eq('table_id', tableId)

    if (countError || total === null) {
      throw new Error('Failed to fetch record count.')
    }

    // ===== FETCH PAGINATED RECORDS
    const offset = (page - 1) * pageSize
    const { data: records, error: recordsError } = await supabase
      .from('entity_records')
      .select('*')
      .eq('table_id', tableId)
      .order('created_at', { ascending: false })
      .range(offset, offset + pageSize - 1)

    if (recordsError) {
      throw new Error('Failed to fetch records.')
    }

    // ===== CALCULATE PAGINATION METADATA
    const totalPages = Math.ceil(total / pageSize)
    const hasNextPage = page < totalPages
    const hasPreviousPage = page > 1

    return success({
      records: (records || []) as EntityRecord[],
      total,
      page,
      pageSize,
      hasNextPage,
      hasPreviousPage,
      totalPages,
    } as PaginatedRecords)
  } catch (error) {
    return failure(error)
  }
}

/**
 * Create a new record in an entity table
 *
 * @param input - UpsertRecordInput with table_id and data
 * @returns ActionResult<EntityRecord>
 */
export async function createEntityRecordAction(
  input: UpsertRecordInput
): Promise<ActionResult<EntityRecord>> {
  try {
    const supabase = await createClient()
    await requireAuth(supabase)

    // Validate input
    const validatedInput = upsertRecordSchema.parse(input)

    // ===== VERIFY TABLE EXISTS AND USER HAS ACCESS
    const { data: table } = await supabase
      .from('entity_tables')
      .select('workspace_id')
      .eq('id', validatedInput.table_id)
      .maybeSingle()

    if (!table) {
      throw new NotFoundError('Table')
    }

    // Verify workspace access
    await requireTableInWorkspace(supabase, validatedInput.table_id, table.workspace_id)

    // ===== CREATE RECORD
    const { data: record, error: recordError } = await supabase
      .from('entity_records')
      .insert({
        table_id: validatedInput.table_id,
        data: validatedInput.data,
      })
      .select()
      .single()

    if (recordError) throw new Error('Failed to create record.')

    // Revalidate table view
    revalidatePath('/dashboard')

    return success(record as EntityRecord)
  } catch (error) {
    return failure(error)
  }
}

/**
 * Update an existing record
 *
 * @param recordId - UUID of the record to update
 * @param tableId - UUID of the table
 * @param data - Partial data to update
 * @returns ActionResult<EntityRecord>
 */
export async function updateEntityRecordAction(
  recordId: string,
  tableId: string,
  data: Record<string, any>
): Promise<ActionResult<EntityRecord>> {
  try {
    const supabase = await createClient()
    await requireAuth(supabase)

    // ===== VERIFY TABLE EXISTS AND USER HAS ACCESS
    const { data: table } = await supabase
      .from('entity_tables')
      .select('workspace_id')
      .eq('id', tableId)
      .maybeSingle()

    if (!table) {
      throw new NotFoundError('Table')
    }

    // Verify workspace access
    await requireTableInWorkspace(supabase, tableId, table.workspace_id)

    // ===== UPDATE RECORD
    const { data: record, error: recordError } = await supabase
      .from('entity_records')
      .update({ data })
      .eq('id', recordId)
      .eq('table_id', tableId)
      .select()
      .single()

    if (recordError) throw new Error('Failed to update record.')

    // Revalidate table view
    revalidatePath('/dashboard')

    return success(record as EntityRecord)
  } catch (error) {
    return failure(error)
  }
}

/**
 * Delete a record
 *
 * @param recordId - UUID of the record to delete
 * @param tableId - UUID of the table (for validation)
 * @returns ActionResult<void>
 */
export async function deleteEntityRecordAction(
  recordId: string,
  tableId: string
): Promise<ActionResult<void>> {
  try {
    const supabase = await createClient()
    await requireAuth(supabase)

    // ===== VERIFY TABLE EXISTS AND USER HAS ACCESS
    const { data: table } = await supabase
      .from('entity_tables')
      .select('workspace_id')
      .eq('id', tableId)
      .maybeSingle()

    if (!table) {
      throw new NotFoundError('Table')
    }

    // Verify workspace access
    await requireTableInWorkspace(supabase, tableId, table.workspace_id)

    // ===== DELETE RECORD
    const { error: deleteError } = await supabase
      .from('entity_records')
      .delete()
      .eq('id', recordId)
      .eq('table_id', tableId)

    if (deleteError) throw new Error('Failed to delete record.')

    // Revalidate table view
    revalidatePath('/dashboard')

    return success(undefined)
  } catch (error) {
    return failure(error)
  }
}
üé® app/actions/entities/projects.ts

'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'
import {
  requireAuth,
  requireWorkspaceAccess,
  NotFoundError,
} from '@/lib/auth/workspace'
import { success, failure, type ActionResult } from '@/lib/types/action-result'
import type { Project, ProjectWithTables, WorkspaceHierarchy } from '@/types/entities'

/**
 * Phase 3 - Projects (Table Spaces) Server Actions
 *
 * Manages projects within a workspace. Projects are intermediate level
 * that contain related tables that can reference each other.
 *
 * All actions use centralized auth helpers to reduce duplication:
 * - requireAuth() for authentication
 * - requireWorkspaceAccess() for authorization
 * - Custom error classes for proper error handling
 */

// ===== Validation schemas
const createProjectSchema = z.object({
  workspace_id: z.string().uuid('workspace_id must be a valid UUID'),
  name: z.string().min(1, 'Project name is required').max(255),
  description: z.string().max(1000).optional().default(''),
  color: z.string().optional().default('blue'),
})

const updateProjectSchema = createProjectSchema.partial().extend({
  project_id: z.string().uuid('project_id must be a valid UUID'),
})

export type CreateProjectInput = z.infer<typeof createProjectSchema>
export type UpdateProjectInput = z.infer<typeof updateProjectSchema>

// ===== CREATE PROJECT
export async function createProjectAction(
  input: CreateProjectInput
): Promise<ActionResult<Project>> {
  try {
    const supabase = await createClient()
    const user = await requireAuth(supabase)

    // Validate input
    const validatedInput = createProjectSchema.parse(input)

    // Verify workspace access (auth + permission check)
    await requireWorkspaceAccess(supabase, user.id, validatedInput.workspace_id)

    // Create project
    const { data: project, error: projectError } = await supabase
      .from('projects')
      .insert({
        workspace_id: validatedInput.workspace_id,
        name: validatedInput.name,
        description: validatedInput.description || null,
        color: validatedInput.color,
      })
      .select()
      .single()

    if (projectError) throw new Error('Failed to create project.')

    // Revalidate paths
    revalidatePath('/dashboard')
    revalidatePath(`/workspace/${validatedInput.workspace_id}`)

    return success(project as Project)
  } catch (error) {
    return failure(error)
  }
}

// ===== GET PROJECT
export async function getProjectAction(
  projectId: string
): Promise<ActionResult<ProjectWithTables>> {
  try {
    const supabase = await createClient()
    const user = await requireAuth(supabase)

    // Get project by ID
    const { data: project, error: projectError } = await supabase
      .from('projects')
      .select('*')
      .eq('id', projectId)
      .maybeSingle()

    if (projectError || !project) {
      throw new NotFoundError('Project')
    }

    // Verify user has access to workspace (this also validates the project workspace_id)
    await requireWorkspaceAccess(supabase, user.id, project.workspace_id)

    // Get all tables in this project
    const { data: tables, error: tablesError } = await supabase
      .from('entity_tables')
      .select('*')
      .eq('project_id', projectId)
      .order('created_at', { ascending: false })

    if (tablesError) throw new Error('Failed to fetch project tables.')

    return success({
      ...project,
      tables: tables || [],
    } as ProjectWithTables)
  } catch (error) {
    return failure(error)
  }
}

// ===== UPDATE PROJECT
export async function updateProjectAction(
  input: UpdateProjectInput
): Promise<ActionResult<Project>> {
  try {
    const supabase = await createClient()
    const user = await requireAuth(supabase)

    // Validate input
    const validatedInput = updateProjectSchema.parse(input)

    // Get project and verify it exists
    const { data: project, error: projectError } = await supabase
      .from('projects')
      .select('workspace_id')
      .eq('id', validatedInput.project_id)
      .maybeSingle()

    if (projectError || !project) {
      throw new NotFoundError('Project')
    }

    // Verify workspace access
    await requireWorkspaceAccess(supabase, user.id, project.workspace_id)

    // Update project
    const updateData: Record<string, any> = {}
    if ('name' in validatedInput && validatedInput.name)
      updateData.name = validatedInput.name
    if ('description' in validatedInput) updateData.description = validatedInput.description
    if ('color' in validatedInput) updateData.color = validatedInput.color

    const { data: updatedProject, error: updateError } = await supabase
      .from('projects')
      .update(updateData)
      .eq('id', validatedInput.project_id)
      .select()
      .single()

    if (updateError) throw new Error('Failed to update project.')

    revalidatePath('/dashboard')
    revalidatePath(`/workspace/${project.workspace_id}`)

    return success(updatedProject as Project)
  } catch (error) {
    return failure(error)
  }
}

// ===== DELETE PROJECT
export async function deleteProjectAction(projectId: string): Promise<ActionResult<void>> {
  try {
    const supabase = await createClient()
    const user = await requireAuth(supabase)

    // Get project and verify it exists
    const { data: project, error: projectError } = await supabase
      .from('projects')
      .select('workspace_id')
      .eq('id', projectId)
      .maybeSingle()

    if (projectError || !project) {
      throw new NotFoundError('Project')
    }

    // Verify workspace access
    await requireWorkspaceAccess(supabase, user.id, project.workspace_id)

    // Delete project (cascade will delete associated tables)
    const { error: deleteError } = await supabase.from('projects').delete().eq('id', projectId)

    if (deleteError) throw new Error('Failed to delete project.')

    revalidatePath('/dashboard')
    revalidatePath(`/workspace/${project.workspace_id}`)

    return success(undefined)
  } catch (error) {
    return failure(error)
  }
}

// ===== GET WORKSPACE HIERARCHY (Projects + Tables)
export async function getWorkspaceHierarchyAction(
  workspaceId: string
): Promise<ActionResult<WorkspaceHierarchy>> {
  try {
    const supabase = await createClient()
    const user = await requireAuth(supabase)

    // Verify workspace access
    await requireWorkspaceAccess(supabase, user.id, workspaceId)

    // Query 1: Fetch all projects in workspace
    const { data: projects, error: projectsError } = await supabase
      .from('projects')
      .select('*')
      .eq('workspace_id', workspaceId)
      .order('created_at', { ascending: false })

    if (projectsError) throw new Error('Failed to fetch projects.')

    // Query 2: Fetch tables in each project
    // TODO: Optimize with nested select once Supabase relationship is defined
    const projectsWithTables: ProjectWithTables[] = []

    for (const project of projects || []) {
      const { data: tables, error: tablesError } = await supabase
        .from('entity_tables')
        .select('*')
        .eq('project_id', project.id)
        .order('created_at', { ascending: false })

      if (!tablesError) {
        projectsWithTables.push({
          ...project,
          tables: tables || [],
        })
      }
    }

    // Query 3: Fetch tables without project (backwards compatibility)
    const { data: orphanTables, error: orphanError } = await supabase
      .from('entity_tables')
      .select('*')
      .eq('workspace_id', workspaceId)
      .is('project_id', null)
      .order('created_at', { ascending: false })

    if (orphanError) throw new Error('Failed to fetch tables.')

    const hierarchy: WorkspaceHierarchy = {
      projects: projectsWithTables,
      tablesWithoutProject: orphanTables || [],
    }

    return success(hierarchy)
  } catch (error) {
    return failure(error)
  }
}
üíå app/actions/entities/invitations.ts

'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'
import { success, failure, type ActionResult } from '@/lib/types/action-result'

interface WorkspaceInvitation {
  id: string
  organization_id: string
  email: string
  token: string
  role: string
  created_by_user_id: string
  created_at: string
  expires_at: string | null
  accepted_at: string | null
  accepted_by_user_id: string | null
}

/**
 * Send an invitation to join an organization
 * Only organization owners/admins can invite
 * 
 * @param organizationId - UUID of the organization
 * @param email - Email of the person to invite
 * @param role - Role for the invited user (default: 'member')
 * @returns ActionResult with invitation details
 */
export async function inviteUserToOrganizationAction(
  organizationId: string,
  email: string,
  role: string = 'member'
): Promise<ActionResult<{ invitation: WorkspaceInvitation }>> {
  try {
    const supabase = await createClient()
    
    // Get current user
    const { data: { user }, error: userError } = await supabase.auth.getUser()
    if (userError || !user) {
      return failure('Non authentifi√©')
    }

    // Verify user is owner/admin of organization
    const { data: membership, error: membershipError } = await supabase
      .from('organization_members')
      .select('role')
      .eq('organization_id', organizationId)
      .eq('user_id', user.id)
      .maybeSingle()

    if (membershipError || !membership || !['owner', 'admin'].includes(membership.role)) {
      return failure('Vous n\'avez pas les permissions pour inviter des utilisateurs')
    }

    // Check if invitation already exists for this email/org
    const { data: existingInvitation } = await supabase
      .from('workspace_invitations')
      .select('id')
      .eq('organization_id', organizationId)
      .eq('email', email)
      .eq('accepted_by_user_id', null)
      .maybeSingle()

    if (existingInvitation) {
      return failure('Une invitation est d√©j√† en attente pour cet email')
    }

    // Generate unique token
    const token = crypto.randomUUID()

    // Create invitation
    const { data: invitation, error: inviteError } = await supabase
      .from('workspace_invitations')
      .insert({
        organization_id: organizationId,
        email: email,
        token: token,
        role: role,
        created_by_user_id: user.id,
        expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), // 7 days
      })
      .select()
      .single()

    if (inviteError || !invitation) {
      console.error('Error creating invitation:', inviteError)
      return failure('Erreur lors de l\'envoi de l\'invitation')
    }

    // TODO: Send email with invitation link
    // For now, just return the token so admin can share manually
    console.log(`[Invitation Created] Email: ${email}, Token: ${token}`)

    revalidatePath(`/dashboard/settings/members`)

    return success({ invitation })
  } catch (error) {
    return failure(error)
  }
}

/**
 * Accept an invitation and join an organization
 * 
 * @param token - Unique invitation token
 * @returns ActionResult with redirect to dashboard
 */
export async function acceptInvitationAction(
  token: string
): Promise<ActionResult<{ organizationId: string }>> {
  try {
    const supabase = await createClient()
    
    // Get current user
    const { data: { user }, error: userError } = await supabase.auth.getUser()
    if (userError || !user) {
      return failure('Non authentifi√© - Veuillez vous connecter')
    }

    // Find invitation by token
    const { data: invitation, error: inviteError } = await supabase
      .from('workspace_invitations')
      .select('*')
      .eq('token', token)
      .maybeSingle()

    if (inviteError || !invitation) {
      return failure('Invitation invalide ou expir√©e')
    }

    // Check if invitation is expired
    if (invitation.expires_at && new Date(invitation.expires_at) < new Date()) {
      return failure('L\'invitation a expir√©')
    }

    // Check if invitation is already accepted
    if (invitation.accepted_at) {
      return failure('Cette invitation a d√©j√† √©t√© accept√©e')
    }

    // Check if email matches current user
    const userEmail = user.email || ''
    if (invitation.email.toLowerCase() !== userEmail.toLowerCase()) {
      return failure('Cette invitation est destin√©e √† un autre email')
    }

    // Check if user is already member of organization
    const { data: existingMember } = await supabase
      .from('organization_members')
      .select('id')
      .eq('organization_id', invitation.organization_id)
      .eq('user_id', user.id)
      .maybeSingle()

    if (existingMember) {
      return failure('Vous √™tes d√©j√† membre de cette organisation')
    }

    // Add user as member of organization
    const { error: memberError } = await supabase
      .from('organization_members')
      .insert({
        organization_id: invitation.organization_id,
        user_id: user.id,
        role: invitation.role,
      })

    if (memberError) {
      console.error('Error adding organization member:', memberError)
      return failure('Erreur lors de l\'ajout √† l\'organisation')
    }

    // Mark invitation as accepted
    const { error: acceptError } = await supabase
      .from('workspace_invitations')
      .update({
        accepted_at: new Date().toISOString(),
        accepted_by_user_id: user.id,
      })
      .eq('token', token)

    if (acceptError) {
      console.error('Error accepting invitation:', acceptError)
      return failure('Erreur lors de l\'acceptation de l\'invitation')
    }

    revalidatePath('/dashboard', 'layout')

    return success({ organizationId: invitation.organization_id })
  } catch (error) {
    return failure(error)
  }
}

/**
 * Get all invitations for an organization
 * Only accessible to organization admins
 * 
 * @param organizationId - UUID of the organization
 * @returns ActionResult with list of invitations
 */
export async function getOrganizationInvitationsAction(
  organizationId: string
): Promise<ActionResult<{ invitations: WorkspaceInvitation[] }>> {
  try {
    const supabase = await createClient()
    
    // Get current user
    const { data: { user }, error: userError } = await supabase.auth.getUser()
    if (userError || !user) {
      return failure('Non authentifi√©')
    }

    // Verify user is owner/admin of organization
    const { data: membership, error: membershipError } = await supabase
      .from('organization_members')
      .select('role')
      .eq('organization_id', organizationId)
      .eq('user_id', user.id)
      .maybeSingle()

    if (membershipError || !membership || !['owner', 'admin'].includes(membership.role)) {
      return failure('Vous n\'avez pas les permissions pour voir les invitations')
    }

    // Get all invitations (pending and accepted)
    const { data: invitations, error: inviteError } = await supabase
      .from('workspace_invitations')
      .select('*')
      .eq('organization_id', organizationId)
      .order('created_at', { ascending: false })

    if (inviteError) {
      return failure('Erreur lors de la r√©cup√©ration des invitations')
    }

    return success({ invitations: invitations || [] })
  } catch (error) {
    return failure(error)
  }
}

/**
 * Delete/revoke an invitation
 * Only accessible to organization admins
 * 
 * @param invitationId - UUID of the invitation
 * @returns ActionResult
 */
export async function revokeInvitationAction(
  invitationId: string
): Promise<ActionResult<null>> {
  try {
    const supabase = await createClient()
    
    // Get current user
    const { data: { user }, error: userError } = await supabase.auth.getUser()
    if (userError || !user) {
      return failure('Non authentifi√©')
    }

    // Get invitation and verify permissions
    const { data: invitation, error: inviteError } = await supabase
      .from('workspace_invitations')
      .select('organization_id')
      .eq('id', invitationId)
      .maybeSingle()

    if (inviteError || !invitation) {
      return failure('Invitation not found')
    }

    // Verify user is owner/admin
    const { data: membership } = await supabase
      .from('organization_members')
      .select('role')
      .eq('organization_id', invitation.organization_id)
      .eq('user_id', user.id)
      .maybeSingle()

    if (!membership || !['owner', 'admin'].includes(membership.role)) {
      return failure('Vous n\'avez pas les permissions')
    }

    // Delete invitation
    const { error: deleteError } = await supabase
      .from('workspace_invitations')
      .delete()
      .eq('id', invitationId)

    if (deleteError) {
      return failure('Erreur lors de la suppression de l\'invitation')
    }

    revalidatePath(`/dashboard/settings/members`)

    return success(null)
  } catch (error) {
    return failure(error)
  }
}
üé® components/datatable/entity-table.tsx

'use client'

import {
  useReactTable,
  getCoreRowModel,
  flexRender,
} from '@tanstack/react-table'
import type { EntityTableWithFields, EntityRecord } from '@/types/entities'
import { useEntityColumns } from './columns-builder'

interface EntityTableProps {
  table: EntityTableWithFields
  initialRecords: EntityRecord[]
}

/**
 * Phase 2.3: EntityTable Component (Updated)
 *
 * Client Component that renders a dynamic table using TanStack Table
 *
 * Props:
 * - table: Table structure with fields (columns metadata)
 * - initialRecords: Array of records (rows data)
 *
 * Features:
 * - Dynamic column generation from entity_fields (via useEntityColumns)
 * - Smart cell rendering (select fields as badges, others as text)
 * - Tailwind styling (borders, header, responsive)
 * - Notion-style color palette for select badges
 *
 * The columns are built by useEntityColumns hook which maps each
 * EntityField to a TanStack ColumnDef with proper accessors and renderers.
 */
export function EntityTable({ table, initialRecords }: EntityTableProps) {
  // ===== 1. GENERATE COLUMNS DYNAMICALLY
  // useEntityColumns transforms entity_fields into TanStack columns
  // with smart rendering for different field types
  const columns = useEntityColumns(table.fields)

  // ===== 2. INITIALIZE TABLE
  const tableInstance = useReactTable({
    data: initialRecords,
    columns,
    getCoreRowModel: getCoreRowModel(),
  })

  const { getHeaderGroups, getRowModel } = tableInstance

  // ===== 3. RENDER
  return (
    <div className="rounded-lg border border-gray-200 bg-white">
      {/* Table Container */}
      <div className="overflow-x-auto">
        <table className="w-full border-collapse">
          {/* Table Header */}
          <thead>
            {getHeaderGroups().map((headerGroup) => (
              <tr key={headerGroup.id} className="border-b border-gray-200 bg-gray-50">
                {headerGroup.headers.map((header) => (
                  <th
                    key={header.id}
                    className="px-6 py-3 text-left text-sm font-semibold text-gray-900"
                  >
                    {header.isPlaceholder
                      ? null
                      : flexRender(header.column.columnDef.header, header.getContext())}
                  </th>
                ))}
              </tr>
            ))}
          </thead>

          {/* Table Body */}
          <tbody>
            {getRowModel().rows.length === 0 ? (
              <tr>
                <td
                  colSpan={columns.length || 1}
                  className="px-6 py-12 text-center text-sm text-gray-500"
                >
                  Aucune donn√©e √† afficher.
                  <br />
                  <span className="text-xs text-gray-400">
                    Les colonnes seront ajout√©es en Phase 2.3
                  </span>
                </td>
              </tr>
            ) : (
              getRowModel().rows.map((row) => (
                <tr key={row.id} className="border-b border-gray-200 hover:bg-gray-50">
                  {row.getVisibleCells().map((cell) => (
                    <td key={cell.id} className="px-6 py-4 text-sm text-gray-700">
                      {flexRender(cell.column.columnDef.cell, cell.getContext())}
                    </td>
                  ))}
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>

      {/* Debug Info */}
      <div className="border-t border-gray-200 bg-gray-50 px-6 py-3">
        <p className="text-xs text-gray-500">
          üìä <strong>{initialRecords.length}</strong> lignes |
          <strong> {table.fields.length}</strong> colonnes dynamiques
        </p>
        <p className="mt-1 text-xs text-gray-400">
          ‚úÖ Phase 2.3: Colonnes g√©n√©r√©es dynamiquement (select fields = badges color√©s)
        </p>
      </div>
    </div>
  )
}
üé® components/datatable/columns-builder.tsx

'use client'

import { useMemo } from 'react'
import { ColumnDef } from '@tanstack/react-table'
import type { EntityField, EntityRecord } from '@/types/entities'

/**
 * Color mapping for select field badges
 * Maps field.options.choices[].color to Tailwind classes
 *
 * Notion-style color palette with background + text color
 */
const colorMap: Record<string, string> = {
  red: 'bg-red-100 text-red-700',
  pink: 'bg-pink-100 text-pink-700',
  purple: 'bg-purple-100 text-purple-700',
  blue: 'bg-blue-100 text-blue-700',
  cyan: 'bg-cyan-100 text-cyan-700',
  teal: 'bg-teal-100 text-teal-700',
  green: 'bg-green-100 text-green-700',
  lime: 'bg-lime-100 text-lime-700',
  yellow: 'bg-yellow-100 text-yellow-700',
  amber: 'bg-amber-100 text-amber-700',
  orange: 'bg-orange-100 text-orange-700',
  gray: 'bg-gray-100 text-gray-700',
  slate: 'bg-slate-100 text-slate-700',
  zinc: 'bg-zinc-100 text-zinc-700',
  // Default
  default: 'bg-gray-100 text-gray-700',
}

/**
 * Get Tailwind classes for a color
 * Safely returns default if color doesn't exist
 */
function getColorClasses(color?: string): string {
  if (!color) return colorMap.default
  return colorMap[color] || colorMap.default
}

/**
 * Phase 2.3: useEntityColumns Hook
 *
 * Transforms EntityField[] into TanStack ColumnDef[]
 *
 * Key features:
 * - Maps field.id ‚Üí column accessor
 * - Maps field.name ‚Üí column header
 * - Accesses row data via row.data[field.id] (JSONB structure)
 * - Smart cell rendering:
 *   - Select fields: Colored badges (Notion-style)
 *   - Other fields: String representation
 * - useMemo for performance optimization
 *
 * @param fields - Array of EntityField from table.fields
 * @returns ColumnDef<EntityRecord>[] ready for TanStack Table
 */
export function useEntityColumns(fields: EntityField[]): ColumnDef<EntityRecord>[] {
  return useMemo(() => {
    return fields.map((field) => ({
      // ===== Column Identifier
      id: field.id,
      header: field.name,

      // ===== Data Accessor
      // Access the JSONB data using the field ID as key
      accessorFn: (row: EntityRecord) => row.data[field.id],

      // ===== Cell Rendering
      cell: (info) => {
        const value = info.getValue()

        // Handle null/undefined
        if (value === null || value === undefined) {
          return <span className="text-gray-400">‚Äî</span>
        }

        // ===== SELECT FIELD: Render as badge
        if (field.type === 'select') {
          // value should be a string or array of strings
          const values = Array.isArray(value) ? value : [String(value)]

          return (
            <div className="flex flex-wrap gap-1">
              {values.map((v, idx) => {
                // Find the choice config to get color
                const choice = field.options?.choices?.find((c) => c.id === v)
                const color = choice?.color

                return (
                  <span
                    key={idx}
                    className={`inline-block rounded-full px-2 py-1 text-xs font-medium ${getColorClasses(color)}`}
                  >
                    {choice?.label || String(v)}
                  </span>
                )
              })}
            </div>
          )
        }

        // ===== OTHER FIELDS: Render as text
        // Convert to string for safe display
        return <span>{String(value)}</span>
      },

      // ===== Column Sizing
      size: 150,
      minSize: 100,
      maxSize: 500,
    }))
  }, [fields])
}